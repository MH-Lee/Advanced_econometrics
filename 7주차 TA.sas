DATA ip;
	INFILE 'c:\data\ip.prn';
	INPUT mon ip;
	ipg=DIF(LOG(ip))*1200;
RUN;
DATA fyff;
	INFILE  'c:\data\fyff.prn';
	INPUT mon fyff;
	fyff4=LAG4(fyff);
RUN;
DATA sp500;
	INFILE 'c:\data\sp500.prn';
	INPUT mon sp500;
	spg=DIF(LOG(sp500))*1200;
RUN;
DATA ex07;
	 MERGE ip fyff;
	 BY mon;
	WHERE 19570101 <= mon <= 20120701;
	 int=1;
RUN;
PROC IML;
USE ex07;
		READ all VAR {ipg} into y;
		READ all VAR {int fyff4} into x;
START reg;
		n = NROW(x);
		k = NCOL(x);
		df = n-k; 
		xpx = x`*x;
		xpy = x`*y;
		xpxi = INV(xpx);
		b = xpxi*xpy;
		yhat = x*b;
		e = y-yhat;
		sse = e`*e;
		mse = sse/df;
		covb = mse#xpxi;
		stdb = SQRT(VECDIAG(covb));
		t = b/stdb;
		probt = 1- PROBF(t#t,1,df);
	print "result of regression are" b stdb t probt;
		e1 = LAG(e,1);
		em = e-e1;
		em[1,1] = 0;
		emsq = em`*em;
		dw=emsq/sse;
	PRINT "durbin watson-d" dw;
FINISH reg;
PRINT "/***original regression***/";
RUN reg;

START coe;
		rho=1-(dw/2);
		x=x[2:n,]-rho*x[1:n-1,]; 
                /*x[2:n,]는 x 벡터의 2번째 행에서 n번째 행까지의 뽑아내기*/
		y=y[2:n,]-rho*y[1:n-1,];
		e=e[2:n,]-rho*e[1:n-1,];
		PRINT rho;
		FINISH coe;
		PRINT "/***cochrane-orcutt estimation 1st***/";
		RUN coe; 
RUN reg;
		PRINT "/***cochrane-orcutt estimation 2nd***/";
		RUN coe; 
RUN reg;
		PRINT "/***cochrane-orcutt estimation 3rd***/";
		RUN coe; 
RUN reg;
QUIT;

PROC AUTOREG DATA=ex07; 
	MODEL ipg=fyff4/NLAG=1 METHOD=ML MAXIT=200; 
	MODEL ipg=fyff4/NLAG=2 METHOD=ML MAXIT=200;
	MODEL ipg=fyff4/NLAG=3 METHOD=ML MAXIT=200;
	MODEL ipg=fyff4/NLAG=4 METHOD=ML MAXIT=200;
RUN;
DATA ip;
INFILE 'c:/ip.prn';
INPUT date ip;
ipg=DIF(LOG(ip))*100;
RUN;
DATA sp500;
INFILE 'c:/sp500.prn';
INPUT date sp500;
spg=DIF(LOG(sp500))*100;
RUN;
DATA ex073;
	MERGE ip sp500;
	BY mon;
	WHERE 19940830<mon <20120801;
RUN; 
DATA ex01;
	MERGE ip sp500;
	BY mon;
	IF 19940830<mon<20120801 THEN mon=mon;
	ELSE delete;
RUN; 
PROC IML;
	USE ex073;
		READ all VAR {ipg} INTO ipg;
		READ all VAR {spg} INTO spg;
	START lag;
		n=NROW(ipg); 

		ipg3=ipg[2:n-3,];
		ipg2=ipg[3:n-2,];
		ipg1=ipg[4:n-1,];
		ipg4=ipg[1:n-4,];
		ipg=ipg[5:n,]; 

		spg3=spg[2:n-3,];
		spg2=spg[3:n-2,];
		spg1=spg[4:n-1,];
		spg4=spg[1:n-4,];
		spg=spg[5:n,];
		int=J(n-4,1,1);
	FINISH lag;
RUN lag; 

	START sse;
		yhat=x*(INV(x`*x))*(x`*y);
		e=y-yhat;
		sse=e`*e;
	FINISH sse; 

		y=spg;
		x=int||ipg1||ipg2||ipg3||ipg4||spg1||spg2||spg3||spg4;
RUN sse;
		sseur_sp=sse;
		dfur=n-ncol(x); 

		y=spg;
		x=int||spg1||spg2||spg3||spg4;
RUN sse;
		sser_sp=sse;
		dfr=(ncol(x))-1;

		y=ipg;
		x=int||ipg1||ipg2||ipg3||ipg4||spg1||spg2||spg3||spg4;
RUN sse;
		sseur_ip=sse;
		dfur=n-ncol(x); 

		y=ipg;
		x=int||ipg1||ipg2||ipg3||ipg4;
RUN sse;
		sser_ip=sse;
		dfr=(ncol(x))-1; 
 
START granger;
		granger_f=((sser-sseur)/dfr)/(sseur/dfur);
		probgranger=1-probf(granger_f,dfr,dfur);
	PRINT "Granger causality TEST", granger_f probgranger;
	PRINT dfr dfur;
FINISH granger; 
 
		sseur=sseur_sp;
		sser=sser_sp;
	PRINT "About SPG";
RUN granger; 
 
		sseur=sseur_ip;
		sser=sser_ip;
	PRINT "About IPG";
RUN granger;
QUIT; 
DATA ex73;
	SET ex01;
	t=_N_;
	ipg1=lag(ipg);
	ipg2=lag2(ipg);
	ipg3=lag3(ipg);
	ipg4=lag4(ipg);
	spg1=lag(spg);
	spg2=lag2(spg);
	spg3=lag3(spg);
	spg4=lag4(spg);
RUN; 
 
PROC REG DATA=ex73;
	MODEL ipg=ipg1 ipg2 ipg3 ipg4 spg1 spg2 spg3 spg4;
	TEST spg1=spg2=spg3=spg4=0;
/*(about ipg에 해당) 0.05보다 작으므로 귀무가설 기각. 이는 spg가 ipg를 granger cause함을 의미한다.*/ MODEL spg=ipg1 ipg2 ipg3 ipg4 spg1 spg2 spg3 spg4;
	TEST ipg1=ipg2=ipg3=ipg4=0;
/*(about spg에 해당) 마찬가지로 pvalue가 0.05보다 작으므로 ipg가 spg를 granger cuase함.*/
RUN;
